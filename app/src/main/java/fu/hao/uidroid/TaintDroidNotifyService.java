package fu.hao.uidroid;

import java.io.*;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.concurrent.*;
import java.text.SimpleDateFormat;
import java.text.ParseException;

import android.app.ActivityManager;
import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Service;
import android.app.ActivityManager.RunningAppProcessInfo;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.os.IBinder;
import android.util.Log;
import android.widget.Button;

public class TaintDroidNotifyService extends Service {
    private static final String TAG = TaintDroidNotifyService.class.getSimpleName();
    private String MYTAG = "UiDroid_Taint";

    private static Hashtable<Integer, String> ttable = new Hashtable<Integer, String>();
    static {
        // ttable.put(new Integer(0x00000000), "No taint");
        ttable.put(new Integer(0x00000001), "Location");
        ttable.put(new Integer(0x00000002), "Address Book (ContactsProvider)");
        ttable.put(new Integer(0x00000004), "Microphone Input");
        ttable.put(new Integer(0x00000008), "Phone Number");
        ttable.put(new Integer(0x00000010), "GPS Location");
        ttable.put(new Integer(0x00000020), "NET-based Location");
        ttable.put(new Integer(0x00000040), "Last known Location");
        ttable.put(new Integer(0x00000080), "camera");
        ttable.put(new Integer(0x00000100), "accelerometer");
        ttable.put(new Integer(0x00000200), "SMS");
        ttable.put(new Integer(0x00000400), "IMEI");
        ttable.put(new Integer(0x00000800), "IMSI");
        ttable.put(new Integer(0x00001000), "ICCID (SIM card identifier)");
        ttable.put(new Integer(0x00002000), "Device serial number");
        ttable.put(new Integer(0x00004000), "User account information");
        ttable.put(new Integer(0x00008000), "browser history");
    }

    private volatile static boolean isRunning = false;

    public static final String KEY_APPNAME = "KEY_APPNAME";
    public static final String KEY_DEST = "KEY_DEST";
    public static final String KEY_TAINT = "KEY_TAINT";
    public static final String KEY_DATA = "KEY_DATA";
    public static final String KEY_ID = "KEY_ID";
    public static final String KEY_TIMESTAMP = "KEY_TIMESTAMP";
    
    private BlockingQueue logQueue;
    private static final int LOGQUEUE_MAXSIZE = 4096;

    private volatile boolean doCapture = false;
    private Thread captureThread = null;


    public static class Starter extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            if(!isRunning && intent.getAction() != null) {
                if(intent.getAction().equals(Intent.ACTION_USER_PRESENT)) {
                    context.startService(new Intent(context, TaintDroidNotifyService.class));
                }
            }
        }
    };

    private class Producer implements Runnable {
    	private final BlockingQueue queue;
    	Producer(BlockingQueue q) { queue = q; }
        public void run() {
            LogcatDevice lc = LogcatDevice.getInstance();
            while(doCapture && lc.isOpen()) {
                try {
                    // read an entry and insert it to our content provider
                    LogEntry le = lc.readLogEntry();
                    if(le != null) {
                        queue.put(le);
                    }
                }
                catch(Exception e) {
                    Log.e(TAG, "Producer could not read log entry: " + e.getMessage());
                    e.printStackTrace();
                }
            }
        }
    };

    private volatile boolean doRead = false;
    private Thread readThread = null;
    private class Consumer implements Runnable {
    	private final BlockingQueue queue;
    	Consumer(BlockingQueue q) { queue = q; }
        public void run()
        {
            LogEntry prev = null;
            while(doRead) {
            	try {
            		LogEntry le = (LogEntry)queue.take();
                    processLogEntry(le);
            	}
            	catch (InterruptedException e) {
            		Log.e(TAG, "Consumer could not read log entry: " + e.getMessage());
            	}
            }
        }
    }

    private String get_processname(int pid) {
        ActivityManager mgr = (ActivityManager) getApplicationContext().getSystemService(
            Context.ACTIVITY_SERVICE);

        String pname = "";
        List<RunningAppProcessInfo> apps = mgr.getRunningAppProcesses();
        for(RunningAppProcessInfo pinfo : apps) {
            if(pinfo.pid == pid) {
                pname = pinfo.processName;
                break;
            }
        }

        return pname;
    }

    private String get_dest(String msg) {
    	Pattern p = Pattern.compile("\\((.+)\\) ");
        Matcher m = p.matcher(msg);

        if(m.find() && m.groupCount() > 0) {
            String result = m.group(1);
            // remove trailing junk
            if (result.contains(")"))
                result = result.substring(0,result.indexOf(")")-1);
            return result;
        }
        else {
            return null;
        }
    }
    
    private String get_smsapp(String msg) {
    	Pattern p = Pattern.compile("from app ((\\S)*) ");
        Matcher m = p.matcher(msg);

        if(m.find() && m.groupCount() > 0) {
            return m.group(1);
        }
        else {
            return null;
        }
    }

    private String get_taint(String msg) {
    	// match hex digits
    	Pattern p = Pattern.compile("with tag 0x(\\p{XDigit}+) ");
        Matcher m = p.matcher(msg);

        if(m.find() && m.groupCount() > 0) {

            String match = m.group(1);

            // get back int
            int taint;
            try {
                taint = Integer.parseInt(match, 16);
            }
            catch(NumberFormatException e) {
                return "Unknown Taint: " + match;
            }

            if(taint == 0x0) {
                return "No taint";
            }

            // for each taint
            ArrayList<String> list = new ArrayList<String>();
            int t;
            String tag;
            
            // check each bit
            for (int i=0; i<32; i++) {
            	t = (taint>>i) & 0x1;
            	tag = ttable.get(new Integer(t<<i));
                if(tag != null) {
                    list.add(tag);
                }
            }

            // build output
            StringBuilder sb = new StringBuilder("");
            if(list.size() > 1) {
                for(int i = 0; i < list.size() - 1; i++) {
                    sb.append(list.get(i) + ", ");
                }
                sb.append(list.get(list.size() - 1));
            }
            else {
                if(!list.isEmpty()) {
                    sb.append(list.get(0));
                }
            }

            return sb.toString();
        }
        else {
            return "No Taint Found";
        }
    }

    private String get_data(String msg) {
        String dataPrefix = "data=[";
        int start = msg.indexOf(dataPrefix) + dataPrefix.length();
        return msg.substring(start);
    }
    
    private int noti_id = 0;

    private void sendTaintDroidNotification(int id, String dest, String taint, String appname, String data, String timestamp) {
        Notification notification = new Notification.BigTextStyle(
        new Notification.Builder(this)
        .setContentTitle("TaintDroid")
        .setContentText(appname)
        .setSmallIcon(R.drawable.icon))
        .bigText(appname+"\n"+dest+"\n"+taint)
        .build();

        // set intent to launch detail
        Bundle extras = new Bundle();
        extras.putString(KEY_APPNAME, appname);
        extras.putString(KEY_DEST, dest);
        extras.putString(KEY_TAINT, taint);
        extras.putString(KEY_DATA, data);
        extras.putInt(KEY_ID, id);
        extras.putString(KEY_TIMESTAMP, timestamp);

        Intent i = new Intent(this, TaintDroidNotifyDetail.class);
        i.addFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);
        i.putExtras(extras);

        PendingIntent pi = PendingIntent.getActivity(this, id, i, PendingIntent.FLAG_UPDATE_CURRENT);
        notification.contentIntent = pi;

        // set led
        notification.ledOnMS = 500;
        notification.ledOffMS = 500;
        notification.ledARGB = 0x00ff0000;
        notification.flags |= Notification.FLAG_SHOW_LIGHTS;

        // send it
        Log.w(MYTAG, appname + ", " + dest + ", " + taint + ", " 
            + ", " + data + ", " + timestamp);
        NotificationManager mgr = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
        mgr.notify(noti_id, notification);
        noti_id++;
    }

    private boolean isTaintedSend(String msg) {
        // covers "libcore.os.send" and "libcore.os.sendto"
        return msg.contains("libcore.os.send");
    }
    
    private boolean isTaintedSSLSend(String msg) {
    	return msg.contains("SSLOutputStream.write");
    }
    
    private boolean isTaintedSMS(String msg) {
        return msg.contains("GsmSMSDispatcher.sendSMS") || msg.contains("CdmaSMSDispatcher.sendSMS");
    }

    private void processLogEntry(LogEntry le) {
        String timestamp = le.getTimestamp();
        String msg = le.getMessage();
        
        boolean doNotify = false;
        
        boolean taintedSend = isTaintedSend(msg);
        boolean taintedSSLSend = isTaintedSSLSend(msg);
        boolean taintedSMS = isTaintedSMS(msg);
        
        String dest="", taint="", app="", data="";
        
        if (taintedSend || taintedSSLSend) {
            dest = get_dest(msg);
            taint = get_taint(msg);
            app = get_processname(le.getPid());
            data = get_data(msg);
            if (taintedSSLSend)
                dest=dest+" (SSL)";
            doNotify = true;
        }
        else if (taintedSMS) {
            dest = get_dest(msg);
            taint = get_taint(msg);
            app = get_smsapp(msg);
            data = get_data(msg);
            doNotify = true;
        }
        
        if (doNotify) {
            // only send notification if recent (within last 5 seconds)
            SimpleDateFormat format = new SimpleDateFormat("MM-dd HH:mm:ss.SSS");
            Date now = new Date();
            Date logDate = new Date();
            try {
                logDate = format.parse(timestamp);
                logDate.setYear(now.getYear());
            } catch (ParseException e) {
                Log.e(TAG, "Error parsing data from log entry");
            }
            long diffSec = TimeUnit.MILLISECONDS.toSeconds(now.getTime()-logDate.getTime());
            
            if (diffSec<5)
                sendTaintDroidNotification(le.hashCode(), dest, taint, app, data, timestamp);
        }
    }

    @Override
    public IBinder onBind(Intent intent) {
        // we don't bind to this service
        return null;
    }

    @Override
    public void onCreate() {
        return;
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        if(isRunning) {
            return START_STICKY;
        }

        logQueue = new ArrayBlockingQueue<LogEntry>(LOGQUEUE_MAXSIZE);
        this.captureThread = new Thread(new Producer(logQueue));
        captureThread.setDaemon(true);

        this.readThread = new Thread(new Consumer(logQueue));
        readThread.setDaemon(true);

        try {
            LogcatDevice.getInstance().open();
        }
        catch(IOException e) {
            Log.e(TAG, "Could not open the log device: " + e.getMessage());
            return START_STICKY;
        }

        this.doCapture = true;
        captureThread.start();

        this.doRead = true;
        readThread.start();

        isRunning = true;

        return START_STICKY;
    }

    @Override
    public void onDestroy() {
        super.onDestroy();

        // stop the thread
        this.doRead = false;
        this.doCapture = false;

        // close the log
        try {
            LogcatDevice.getInstance().close();
        }
        catch(IOException e) {
            Log.e(TAG, "Could not close the log device properly: " + e.getMessage());
        }

        // destroy the thread
        this.readThread.interrupt();
        this.captureThread.interrupt();
        this.readThread = null;
        this.captureThread = null;
        
        isRunning = false;
    }
}
